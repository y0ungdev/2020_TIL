

### 정렬

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것
>
> 키(Key): 자료를 정렬하는 기준이 되는 특정 값

- 종류

  - 버블 정렬
  - 카운팅 정렬
  - 선택 정렬
  - 퀵 정렬
  - 삽입 정렬
  - 병합 정렬

  

#### 1)  버블 정렬(Bubble Sort)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

(1) 정렬 과정

- 첫 번째 원소부터 인접해 있는 원소끼리 계속 위치를 교환하며 맨 마지막 자리까지 이동 ➡ 한 사이클이 끝나면 가장 큰 값의 원소가 마지막 위치로 오게 됨 
- 시간 복잡도 : O(n²)

(2) 배열을 활용한 버블 정렬 코드

```python
def BubbleSort(n) :
    for i in range(len(n)-1, 0, -1):
        for j in range(0,i):
            if n[j] > n[j+1]:
                n[j], n[j+1] = n[j+1], n[j]
```



#### 2) 카운팅 정렬(Counting Sort)

### 배열 2(Array 2)

#### 1) BIT 연산

> 비트 연산(Bitwise Operation)은 한 개 혹은 두 개의 이진수에 대해 Bit 단위로 적용되는 연산이다
>
> -출처: wikipedia

##### (1) BIT 연산자

```python
- & : 비트 단위로 AND 연산을 한다.
- | : 비트 단위로 OR 연산을 한다.
- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
```

* <<연산자 : 1 << n²

원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

- & 연산자 : i & (1<<j)

i의 j번째 비트가 1인지 아닌지를 리턴한다.

##### (2) Python 코드로 부분집합을 생성하는 방법

```python
arr = [1, 2, 3, 4, 5, 6]
n = len(arr) 					# n: 원소의 개수
for i in range(1<<n): 			# 1<<n : 부분집합의 수
    for j in range(n+1):		# 원소의 수만큼 비트를 비교하고
        if i & (i <<j):			# i의 j번째 비트가 1이라면
            print(arr[j], end=',') # j번째 원소를 출력한다
    print()
print()
```



#### 2) 2차원 배열

> - 1차원 List를 묶어놓은 List
> - 2차원 이상의 다차원 List는 차원에 따라 Index를 선언함.
> - 



